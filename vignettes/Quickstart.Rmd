---
title: "PCAGenomicSignatures - Quickstart"
author: "Sehyun Oh"
date: "`r format(Sys.time(), '%B %d, %Y')`"
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Quickstart}
  %\VignetteEncoding{UTF-8}
output:
  BiocStyle::html_document:
    number_sections: no
    toc: yes
    toc_depth: 4
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "#>", collapse = TRUE, message = FALSE, warning = FALSE 
)
```

# Setup

## Install and load package
```{r eval = FALSE}
if (!require("devtools")) {
  install.packages("devtools")
}
devtools::install_github("shbrief/PCAGenomicSignatures")
```

```{r results="hide", message=FALSE, warning=FALSE}
library(PCAGenomicSignatures)
```


## Download PCAmodel
Currently, you can download PCAGenomicSignatures from Google Cloud bucket using 
`PCAGenomicSignatures::getModel` function. This model is built from top 20 PCs of 
536 studies (containing 44,890 samples) containing 13,934 common genes from each 
of 536 study's top 90% varying genes based on thier study-level standard deviation.
There are two versions of this using different gene sets for GSEA-based annotation;
MSigDB C2 (`C2`) and three priors from PLIER package (`PLIERpriors`). In this 
vignette, we are using the `C2` annotated model.

```{r load_model}
wd <- getwd()
fpath <- file.path(wd, "PCAmodel_C2.rds")
if (!file.exists(fpath)) {getModel("C2", dir = wd)} 

PCAmodel <- readRDS(file.path(wd, "PCAmodel_C2.rds"))
PCAmodel
```


## Example dataset
**Human B-cell expression dataset** The human B-cell dataset (Gene Expression Omnibus series GSE2350) 
consists of 211 normal and tumor human B-cell phenotypes whose expression was profiled on Affymatrix
HG-U95Av2 arrays, and it is contained in an ExpressionSet object with 6,249 features x 211 samples.

```{r echo=FALSE}
if (!"BiocManager" %in% rownames(installed.packages())) {install.packages("BiocManager")}
if (!"bcellViper" %in% rownames(installed.packages())) {BiocManager::install("bcellViper")}
```

```{r message=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(bcellViper))
data(bcellViper)
dset
dataset <- exprs(dset)   # genes in SYMBOL
```

You can provide your own expression dataset in any of these formats: simple matrix, 
ExpressionSet, or SummarizedExperiment. Just make sure that genes in rows are in
a 'symbol' format. 


# Validate
## HeatmapTable
`heatmapTable` outputs a two panel table: top panel represents average silhouette
width (avg.sw) and the bottom panel represents the validation score.

You can display the validation output in multiple ways. For example, if you specify 
`scoreCutoff` argument of `heatmapTable`, any validation result above that score 
will be shown. If you specify the number of top validation results (= n) 
through `num.out` argument of `heatmapTable`, the output will be a n-columned
heatmap table. You can also use the average silhouette width (`swCutoff`), the 
size of cluster (`clsizecutoff`), PC from dataset (`whichPC`).   

Here, we print out top 5 validated PCclusters with > 0 average silhouette width.

```{r fig.width=4.5, fig.height=2.5, message=FALSE, warning=FALSE}
val_all <- validate(dataset, PCAmodel)  
heatmapTable(val_all, num.out = 5, swCutoff = 0)
```

## Interactive Graph
Under the default condition, `plotValidate` plots all non single-element clusters'
validation results in a single graph, where x-axis represent average silhouette
width of the PCclusters (a quality control measure of the signature) and y-axis
represent validation score. We recommend users to focus on PCclusters with higher
validation score and use avgerage silhouette width as a secondary criteria. 

```{r plotValidate_function}
plotValidate(val_all, interactive = FALSE)
plotValidate(val_all, interactive = TRUE, minClusterSize = 4)
```

<br>

You can hover each data point for more information:    
- **sw** : the average silhouette width of the clutser   
- **score** : the top validation score between 8 PCs of the dataset and the cluster   
- **cl_size** : the size of the cluster, represented by the dot size   
- **cl_num** : the PCcluster number. You need this index to find more information about the cluster.      
- **PC** : Test dataset's PC number that validates the given PCcluster. Because we used 
top 8 PCs of the test dataset, there are 8 categories. 

If you double-click the PC legend on the right, you will enter an individual display
mode where you can add an additional group of data point by single-click. 


# MeSH terms in wordcloud
You can draw a wordcloud with the enriched MeSH term of PCclusters that validate
your dataset. Besed on the heatmap table above, 1st-3rd PCclusters (2538, 1139, 884) 
show high validation scores with positive average silhouette widths, so we draw 
wordclouds of those PCclusters using `drawWordcloud` function. You need to provide 
PCAmodel and the index of the PCcluster you are interested in.

Index of validated PCclusters can be easily collected using `validatedSingatures`
function, which outputs the validated index based on `num.out`, PC from dataset 
(`whichPC`) or any `*Cutoff` arguments in a same way as `heatmapTable`. 

```{r fig.height=8, fig.width=8}
validatedSig <- validatedSignatures(val_all, num.out = 3, swCutoff = 0)
validated_ind <- validatedSig[,"cl_num"]

set.seed(1)
drawWordcloud(PCAmodel, validated_ind[1])
drawWordcloud(PCAmodel, validated_ind[2])
drawWordcloud(PCAmodel, validated_ind[3])
```




# GSEA
## Annotation on PCcluster1139
Because the test dataset is human B-cell expression data, we tried the model annotated
with blood-associated gene sets. 

```{r message=FALSE, warning=FALSE}
wd <- getwd()
fpath <- file.path(wd, "PCAmodel_PLIERpriors.rds")
if (!file.exists(fpath)) {getModel("PLIERpriors", dir = wd)} 

PCAmodel <- readRDS(file.path(wd, "PCAmodel_PLIERpriors.rds"))
PCAmodel
```

You can directly access the GSEA outputs for each PCcluster using the accessor, `gsea`.

```{r}
PCNum <- validated_ind[2]   # PCcluster1139
res <- gsea(PCAmodel)[[PCNum]]   
head(res)
```


Find the PCclusters annotated with the keyword-containing pathways. Without the `k` argument, 
the data frame containing the number of PCclusters (`Freq` column) with the different numbers 
of keyword-containing, enriched pathways (`# of keyword-containing pathways` column).

```{r}
findSignature(PCAmodel, "Bcell")
findSignature(PCAmodel, "Bcell", k = 5)
```

Enriched pathways of the given PCAmodel, ordered by NES. If `both=TRUE`, both the
top and bottom enriched pathways will be printed.

```{r}
subsetPathways(PCAmodel, ind = PCNum, n = 3, both = TRUE)
subsetPathways(PCAmodel, ind = 695, n = 3, both = TRUE)
subsetPathways(PCAmodel, ind = 1994, n = 3, both = TRUE)
```


```{r}
annotatePCcluster(PCAmodel, ind = PCNum, n = 3, abs = FALSE)
annotatePCcluster(PCAmodel, ind = 695, n = 3, abs = FALSE)
annotatePCcluster(PCAmodel, ind = 1994, n = 3, abs = FALSE)
```










```{r collapse=FALSE, echo=FALSE, eval=FALSE}
### Ordered by NES
msC2_2nes <- msC2_2[order(msC2_2$NES, decreasing = TRUE),]
ind2 <- grep(keyword, msC2_2nes$Description, ignore.case = TRUE) # index containing keyword

print(paste("The number of enriched pathways =", nrow(msC2_2nes)))
print(paste("The number of enriched pathways containing keyword =", length(ind2)))

### Ordered by qvalues
msC2_2qval <- msC2_2[order(msC2_2$qvalues, decreasing = FALSE),]
ind2 <- grep(keyword, msC2_2qval$Description, ignore.case = TRUE) # index containing keyword

print(paste("The number of enriched pathways =", nrow(msC2_2qval)))
print(paste("The number of enriched pathways containing keyword =", length(ind2)))
```







```{r echo=FALSE, eval=FALSE}
res1 <- msigdb_gsea(validated_ind[1], PCAmodel, category = "C2")
dim(res1)

gseaSub <- subsetGSEA(res1, n = 20)
gseaBarplot(gseaRes = gseaSub)
res_os <- gseaNetwork(gseaRes = gseaSub, similarity_metric = "overlap_similarity", similarity_cutoff = 0.3)
res_js <- gseaNetwork(gseaRes = gseaSub, similarity_metric = "jaccard_similarity", similarity_cutoff = 0.3)

visNetwork::visSave(res_os, file = "res_os.html")
htmltools::includeHTML("res_os.html")

visNetwork::visSave(res_js, file = "res_js.html")
htmltools::includeHTML("res_js.html")
```


```{r echo=FALSE, eval=FALSE}
res2 <- msigdb_gsea(validated_ind[2], PCAmodel, category = "C2")
dim(res2)

gseaSub <- subsetGSEA(res2, n = 20)
gseaBarplot(gseaRes = gseaSub)
gseaNetwork(gseaRes = gseaSub, similarity_metric = "overlap_similarity", similarity_cutoff = 0.3)
gseaNetwork(gseaRes = gseaSub, similarity_metric = "jaccard_similarity", similarity_cutoff = 0.3)
```


```{r echo=FALSE, eval=FALSE}
res3 <- msigdb_gsea(validated_ind[3], PCAmodel, category = "C2")
dim(res3)

gseaSub <- subsetGSEA(res3, n = 20)
gseaBarplot(gseaRes = gseaSub)
gseaNetwork(gseaRes = gseaSub, similarity_metric = "overlap_similarity", similarity_cutoff = 0.3)
gseaNetwork(gseaRes = gseaSub, similarity_metric = "jaccard_similarity", similarity_cutoff = 0.3)
```


```{r echo=FALSE, eval=FALSE}
res4 <- msigdb_gsea(validated_ind[4], PCAmodel, category = "C2")
dim(res4)

gseaSub <- subsetGSEA(res4, n = 20)
gseaBarplot(gseaRes = gseaSub)
gseaNetwork(gseaRes = gseaSub, similarity_metric = "overlap_similarity", similarity_cutoff = 0.3)
gseaNetwork(gseaRes = gseaSub, similarity_metric = "jaccard_similarity", similarity_cutoff = 0.3)
```

